\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[UTF8]{ctex}
\usepackage{url}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{a4paper,scale=0.8}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},      % choose the background color
	basicstyle=\footnotesize\ttfamily,  % size of fonts used for the code
	columns=flexible,
	tabsize=4,
	breaklines=true,               % automatic line breaking only at whitespace
	captionpos=b,                  % sets the caption-position to bottom
	commentstyle=\color{mygreen},  % comment style
	escapeinside={\%*}{*)},        % if you want to add LaTeX within your code
	keywordstyle=\color{blue},     % keyword style
	stringstyle=\color{mymauve}\ttfamily,  % string literal style
	frame=single,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c,
}

\title{实践指导}
\author{吴清晏(61522314) \\ 东南大学吴健雄学院}

\date{}

\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{3}

\begin{document}

\maketitle

\newpage
\renewcommand{\abstractname}{\LARGE\textbf{前言}}
\begin{abstract}\large

	~\\
	感谢您使用《openEuler 内核开发实践指导》！

	本手册是由董恺老师发起，学生孙彦林基于《中国科学院大学<操作系统>课程实验课指导书》进行编写的课程实践指导手册。为了满足实验的最新需求和学生的学习需求，我们对原有内容进行更新与修复，通过分析和解答学生在实验中遇到的问题，以确保内容的准确性和完整性。

	本手册旨在引导您进行《openEuler 内核开发实践》课程实践实验，提供全面而系统的指导。通过本实验，您将有机会亲身参与开源操作系统的开发，学习并应用现代操作系统的设计原则、调度算法、内存管理和设备驱动等关键概念。

	我们特别强调实验的流程性描述，以确保您能够按照正确的顺序进行实验操作，并理解每个步骤的目的和意义。每个实验步骤都经过精心设计和验证，旨在帮助您逐步掌握内核开发所需的技能和知识。

	董恺老师是一位经验丰富、富有激情的教育工作者，对操作系统领域有着深厚的知识和独到的见解。他在整个编写过程中提供了宝贵的指导和建议。 同时，我们要感谢中国科学院大学《操作系统》课程实验课指导书的编写团队。他们经过精心的策划和努力，为学生们提供了一份详尽而系统的指导材料。这个团队的辛勤工作和专业知识为本手册的编写提供了坚实的基础。

	我们希望通过本手册，能够帮助您更好地理解和应用操作系统内核开发的关键概念和技术。我们相信，通过实验的实践和理论的结合，您将能够获得宝贵的经验和深入的学习成果。

	最后，我们衷心希望本手册能够对您的学习和实践产生积极的影响。如果您在使用过程中遇到任何问题或困惑，我们鼓励您及时寻求指导和支持。

	再次感谢董恺老师和中国科学院大学《操作系统》课程实验课指导书的编写团队的辛勤付出！

	祝您在《openEuler 内核开发实践》课程实践中取得优异的成绩！

	敬祝学习愉快！
\end{abstract}

\newpage
\begin{center}
	\tableofcontents
\end{center}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{page}{1}
\pagestyle{headings}

\section{\textit{openEuler}操作系统安装与内核编译}

\subsection{任务1：openEuler操作系统安装（30min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 下载最新版本的 openEuler 操作系统；将其安装至树莓派 4B 上。
	\item 获取树莓派中 openEuler 系统的 IP 地址，使用 ssh 远程登录。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 在树莓派 4B 中成功安装 openEuler 操作系统，使用用户名/密码正常登陆。
	\item 使用 ssh 远程登录成功。
	\item 提交相关流程截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 树莓派刷机
	      \begin{enumerate}
		      \item 实验环境
		            \begin{itemize}
			            \item windows10
			            \item 树莓派4B/4G RAM
			            \item 16G以上的 micro SD卡
		            \end{itemize}
		      \item 获取树莓派img镜像
		            \begin{itemize}
			            \item \url{https://repo.openeuler.org/openEuler-20.03-LTS-SP4/raspi_img}
			            \item 下载img.xz文件
			            \item 可通过sha256sum文件校验镜像完整性
			            \item 若下载的镜像扩展名是iso，可直接将下载的镜像的扩展名重命名修改为img。
		            \end{itemize}
		      \item 格式化SD卡
		            \begin{itemize}
			            \item 使用SDFormatter
			            \item 若SD卡之前未安装过镜像，盘符正常只有一个，直接格式化即可；
			            \item 如果若SD卡之前安装过镜像，则会出现多个盘符，格式化带有容量标记的即可。
			            \item 格式化结果为一个盘符，存储占用为空
		            \end{itemize}
		      \item 写入SD卡
		            \begin{itemize}
			            \item 使用管理员身份运行Win32 Disk Imager
			            \item 将镜像写入格式化后的磁盘
			            \item 结果会产生多个盘符
		            \end{itemize}
		      \item 分区扩容
		            \begin{itemize}
			            \item 使用时的系统大小为boot盘的大小，可调整分区为boot盘扩容。
			            \item 参考\url{https://gitee.com/openeuler/raspberrypi/blob/master/documents/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8.md}
		            \end{itemize}
	      \end{enumerate}
	\item 启用树莓派
	      \begin{enumerate}
		      \item 启动树莓派
		      \item PC下载SSH链接工具
		      \item 链接显示器获取树莓派IP
		            \begin{itemize}
			            \item 使用HDMI视频输出树莓派界面
			            \item 使用\verb|uname -a|命令查看IP信息
		            \end{itemize}
		      \item 同一局域网下获取树莓派IP
		            \begin{itemize}
			            \item 树莓派与windows10的PC有线接入同一个路由器
			            \item PC端登入路由，查看Pi4B IP
		            \end{itemize}
		      \item 有线链接获取树莓派IP方法：
		            \begin{itemize}
			            \item 通过网线将树莓派与PC链接
			            \item PC端通过命令行使用\verb|arp -a|命令查看局域网所有IP信息
			            \item 在PC端网络连接设置界面将网络与树莓派连接共享
			            \item 再次使用\verb|arp -a|命令，对比IP变化
			            \item 新增的内容包含树莓派IP地址
		            \end{itemize}
		      \item ssh连接命令\verb|ssh root@[Pi4B IP]|
		      \item openEuler的用户名/密码一般是：root/openeuler
	      \end{enumerate}
\end{enumerate}

\newpage

\subsection{任务2：openEuler内核编译与安装（30min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 下载 openEuler-20.03-LTS-SP3版本镜像对应的内核源码，编译内核源码。
	\item 编译完成后安装/更新内核。
	\item 由于内核编译过程耗时较长，可在编译的同时进行[任务3]的实验内容。
\end{enumerate}
\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编译内核源码，并完成安装。
	\item 提交新旧内核版本的截图。
\end{enumerate}
\subsubsection{操作指南}
\begin{enumerate}
	\item 查看原始系统信息(截图留存)
	      \begin{lstlisting}
# uname -a    # 查看内核版本信息
\end{lstlisting}
	\item 安装文件传输工具
	      \begin{lstlisting}
# dnf install lrzsz
\end{lstlisting}
	      \begin{itemize}
		      \item 该工具可以较为方便的在PC与树莓派之间传输文件，有助于调试与后续实验。
		      \item 若\verb|cz|和\verb|rz|命令无法使用，尝试更换支持此功能的SSH链接工具，如XShell。
		      \item 该工具不可传输大文件
	      \end{itemize}

	\item 系统备份
	      \begin{lstlisting}
# cd ~
# dnf install tar
# tar czvf boot_origin.tgz /boot/
# sz boot_origin.tgz      #将备份文件发送到本地(可选)
    \end{lstlisting}

	\item 注册账号、密钥
	      \begin{enumerate}
		      \item 注册gitee账号
		            \begin{itemize}
			            \item https://gitee.com/
		            \end{itemize}
		      \item 生成并部署SSH key
		            \begin{itemize}
			            \item http://git.mydoc.io/?t=154712
		            \end{itemize}
		      \item 测试ssh是否配置成功
		            \begin{lstlisting}
# ssh -T git@gitee.com
\end{lstlisting}
	      \end{enumerate}
	      \begin{itemize}
		      \item 如果未部署SSH key可以选择本地传输方式：
		            \begin{enumerate}
			            \item 登录后将内核源码压缩包下载至PC。
			            \item \url{https://gitee.com/openeuler/raspberrypi-kernel/tree/openEuler-20.03-LTS/}
			            \item 树莓派使用\verb|rz|命令将PC上压缩包传输至树莓派。
		            \end{enumerate}
	      \end{itemize}

	\item 内核源码下载
	      \begin{lstlisting}
# dnf install wget
# wget https://gitee.com/openeuler/raspberrypi-kernel/repository/archive/openEuler-20.03-LTS.zip
# unzip openEuler-20.03-LTS.zip
# cd raspberrypi-kernel
\end{lstlisting}
	      \begin{itemize}
		      \item \verb|wget|是一个在网络上进行下载的软件
		      \item 网站需要在SSH配置成功前提下才可下载
		      \item 网站在PC端需要登录后才可打开
		      \item \textbf{需要使用raspberrypi-kernel目录下的树莓派内核}，不要使用kernel仓库中的内核，否则本实验不会报错但是后续实验会无法进行。
	      \end{itemize}


	\item 编译内核\\
	      在根目录下，输入：
	      \begin{lstlisting}
# dnf install gcc bison flex openssl-devel bc
# make openeuler-raspi_defconfig
# make -j4 Image modules dtbs    #耗时长
# make modules_install
\end{lstlisting}
	\item 安装、升级内核
	      \begin{lstlisting}
# cp arch/arm64/boot/Image /boot/kernel8.img
# cp arch/arm64/boot/dts/broadcom/*.dtb /boot/          
# cp arch/arm64/boot/dts/overlays/*.dtb* /boot/overlays/
# cp arch/arm64/boot/dts/overlays/README /boot/overlays/
\end{lstlisting}
	\item 重启系统
	      \begin{lstlisting}
# reboot
# uname -a    # 查看内核版本信息
Linux openEuler 4.19.90 #1 SMP PREEMPT Mon May 31 19:27:46 
CST 2021 aarch64 aarch64 aarch64 GNU/Linux
\end{lstlisting}
	\item 问题解决
	      \begin{itemize}
		      \item 如果启动失败，请把备份好的boot\_origin.tgz解压覆盖到/boot中并重启
		      \item 如果编译操作系统过程中提示变量重命名，可尝试对gcc进行版本降级，或者修改内核源码，将二次定义变量行删除
	      \end{itemize}
\end{enumerate}

\newpage
\subsection{任务3：内核模块编程（30min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块，功能是打印“hello,world!”字符串。
	\item 编写对应Makefile文件，并使用make编译上述内核模块。
	\item 手动加载内核模块，查看加载内容。
	\item 手动卸载上述内核模块。
\end{enumerate}
\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}
\subsubsection{操作指南}
\begin{enumerate}
	\item 内核预编译
	      \begin{lstlisting}
# cd ~\raspberrypi-kernel
# make openeuler-raspi_defconfig    # 加载内核配置
# make prepare && make scripts    # 内核预编译（耗时短）
\end{lstlisting}
	\item 创建路径、.c文件、Makefile文件
	      \begin{lstlisting}
# cd ~\raspberrypi-kernel
# mkdir labwork_1.3
# cd labwork_1.3
# vim helloworld.c
# vim Makefile
\end{lstlisting}
	\item 使用vim
	      \begin{itemize}
		      \item 进入vim后，默认进入命令模式
		      \item 命令模式依次键入[:][q][Enter]退出vim
		      \item 命令模式按[i]进入插入模式，随光标键入内容
		      \item 插入模式按[esc]进入命令模式
		      \item 命令模式依次键入[:][w][Enter]保存，或[:wq]保存退出
		      \item 其余模式及操作请自行查阅资料
	      \end{itemize}
	\item 编辑helloworld.c
	      \begin{lstlisting}[numbers=left]
#include<linux/module.h>
MODULE_LICENSE("GPL");

int __init hello_init(void) {
	printk("hello init\n");
	printk("hello,world!\n");
	return 0;
}
void __exit hello_exit(void) {
	printk("hello exit\n");
}
module_init(hello_init);
module_exit(hello_exit);
\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := helloworld.o
else
	KERNELDIR ?=/root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
\end{lstlisting}
	\item 执行make编译源码
	      \begin{lstlisting}
[root@openEuler labwork_1.3]# make
make -C /root/raspberrypi-kernel M=/root/raspberrypi-
kernel/labwork_1.3 modules
make[1]: Entering directory '/root/raspberrypi-kernel'
  Building modules, stage 2.
  MODPOST 1 modules
make[1]: Leaving directory '/root/raspberrypi-kernel'
[root@openEuler labwork_1.3]#
\end{lstlisting}
	\item 进行模块加载、查看、卸载
	      \begin{lstlisting}
# dmesg -c    # 查看并清空消息
# dmesg    # 消息已清空
# insmod helloworld.ko    # 加载
# lsmod | grep hello    # 查看模块，结果中查找hello字串
# dmesg -c
# rmmod helloworld.ko    # 卸载
# lsmod | grep hello
# dmesg
\end{lstlisting}
\end{enumerate}

\newpage
\section{内存管理}
\subsection{任务1：使用 kmalloc 分配 1KB，8KB的内存，并打印指针地址（20min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 使用 kmalloc 分配 1KB，8KB的内存，打印指针地址；
	\item 查看已分配的内存，根据机器是32位或64位的情况，分析地址落在的区域。
\end{enumerate}
\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码、运行截图以及内存分配情况的解释。
\end{enumerate}
\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑kmalloc.c
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");

unsigned char *kmallocmem1;
unsigned char *kmallocmem2;

static int __init mem_module_init(void){
	printk("Start kmalloc!\n");
	kmallocmem1 = (unsigned char *)kmalloc(1024, GFP_KERNEL);
	if (kmallocmem1 != NULL){
		printk(KERN_ALERT "kmallocmem1 addr = %lx\n", (unsigned long)kmallocmem1);
	}
	else{
		printk("Failed to allocate kmallocmem1!\n");
	}
	kmallocmem2 = (unsigned char *)kmalloc(8192, GFP_KERNEL);
	if (kmallocmem2 != NULL){
		printk(KERN_ALERT "kmallocmem2 addr = %lx\n", (unsigned long)kmallocmem2);
	}
	else{
		printk("Failed to allocate kmallocmem2!\n");
	}
	return 0;
}

static void __exit mem_module_exit(void){
	kfree(kmallocmem1);
	kfree(kmallocmem2);
	printk("Exit kmalloc!\n");
}

module_init(mem_module_init);
module_exit(mem_module_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := kmalloc.o
else
	KERNELDIR ?=/root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
    \end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
	\item 判断地址位于内核空间还是用户空间
	      \begin{itemize}
		      \item 使用\verb|arch|命令查询CPU位数
		      \item 通过\verb|getconf PAGE_SIZE|命令获得页大小
		      \item 打开\verb|arch/arm64/configs/openeuler-raspi_defconfig|文件，其中\\ \verb|CONFIG_PGTABLE_LEVELS=4|表明页表级数。
		      \item 通过获得的信息，在官方文件\url{https://www.kernel.org/doc/Documentation/arm64/memory.txt}中检索得到用户内存与内核内存的范围。
	      \end{itemize}
\end{enumerate}
\newpage

\subsection{任务2：使用vmalloc分别分配8KB、1MB、64MB的内存，打印指针地址（20min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 使用 vmalloc 分配 8KB、1MB、64MB 的内存，打印指针地址；
	\item 查看已分配的内存，根据机器是32位或64位的情况，分析地址落在的区域。
\end{enumerate}
\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码、运行截图以及内存分配情况的解释。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑vmalloc.c
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/vmalloc.h>

MODULE_LICENSE("GPL");

unsigned char *vmallocmem1;
unsigned char *vmallocmem2;
unsigned char *vmallocmem3;

static int __init mem_module_init(void)
{
	printk("Start vmalloc!\n");
	vmallocmem1 = (unsigned char *)vmalloc(8192);
	if (vmallocmem1 != NULL)
	{
		printk("vmallocmem1 addr = %lx\n", (unsigned long)vmallocmem1);
	}
	else
	{
		printk("Failed to allocate vmallocmem1!\n");
	}
	vmallocmem2 = (unsigned char *)vmalloc(1048576);
	if (vmallocmem2 != NULL)
	{
		printk("vmallocmem2 addr = %lx\n", (unsigned long)vmallocmem2);
	}
	else
	{
		printk("Failed to allocate vmallocmem2!\n");
	}
	vmallocmem3 = (unsigned char *)vmalloc(67108864);
	if (vmallocmem3 != NULL)
	{
		printk("vmallocmem3 addr = %lx\n", (unsigned long)vmallocmem3);
	}
	else
	{
		printk("Failed to allocate vmallocmem3!\n");
	}
	return 0;
}

static void __exit mem_module_exit(void)
{
	vfree(vmallocmem1);
	vfree(vmallocmem2);
	vfree(vmallocmem3);
	printk("Exit vmalloc!\n");
}

module_init(mem_module_init);
module_exit(mem_module_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := vmalloc.o
else
	KERNELDIR ?=/root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
	\item 判断地址位于内核空间还是用户空间
\end{enumerate}

\newpage



\section{进程管理}

\subsection{任务1：创建并运行内核线程（15min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块，创建一个内核线程；并在模块退出时杀死该线程。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑kthread.c
	      \begin{lstlisting}[numbers=left]
#include <linux/kthread.h>
#include <linux/module.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");

#define BUF_SIZE 20

static struct task_struct *myThread = NULL;

static int print(void *data)
{
	while (!kthread_should_stop())
	{
		printk("New kthread is running. 2sec per msg.\n");
		msleep(2000);
	}
	return 0;
}

static int __init kthread_init(void)
{
	printk("Create kernel thread!\n");
	myThread = kthread_run(print, NULL, "new_kthread");
	return 0;
}

static void __exit kthread_exit(void)
{
	printk("Kill new kthread.\n");
	if (myThread)
		kthread_stop(myThread);
}

module_init(kthread_init);
module_exit(kthread_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := kthread.o
else
	KERNELDIR ?=/root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage

\subsection{任务2：打印输出当前系统 CPU 负载情况（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写一个内核模块，实现读取系统一分钟内的CPU负载。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|cpu_loadavg.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/fs.h>

MODULE_LICENSE("GPL");

char tmp_cpu_load[5] = {'\0'};

static int get_loadavg(void)
{
	struct file *fp_cpu;
	loff_t pos = 0;
	char buf_cpu[10];
	fp_cpu = filp_open("/proc/loadavg", O_RDONLY, 0);
	if (IS_ERR(fp_cpu))
	{
		printk("Failed to open loadavg file!\n");
		return -1;
	}
	kernel_read(fp_cpu, buf_cpu, sizeof(buf_cpu), &pos);
	strncpy(tmp_cpu_load, buf_cpu, 4);
	filp_close(fp_cpu, NULL);
	return 0;
}

static int __init cpu_loadavg_init(void)
{
	printk("Start cpu_loadavg!\n");
	if (0 != get_loadavg())
	{
		printk("Failed to read loadarvg file!\n");
		return -1;
	}
	printk("The cpu loadavg in one minute is: %s\n", tmp_cpu_load);
	return 0;
}

static void __exit cpu_loadavg_exit(void)
{
	printk("Exit cpu_loadavg!\n");
}

module_init(cpu_loadavg_init);
module_exit(cpu_loadavg_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := cpu_loadavg.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage

\subsection{任务3：打印输出当前处于运行状态的进程的 PID 和名字（15min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写一个内核模块，打印当前系统处于运行状态的进程的PID和名字。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|process_info.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/sched/signal.h>
#include <linux/sched.h>

MODULE_LICENSE("GPL");

struct task_struct *p;

static int __init process_info_init(void)
{
	printk("Start process_info!\n");
	for_each_process(p)
	{
		if (p->state == 0)
			printk("1)name:%s\t2)pid:%d\t3)state:%ld\n", p->comm, p->pid, p->state);
	}
	return 0;
}

static void __exit process_info_exit(void)
{
	printk("Exit process_info!\n");
}

module_init(process_info_init);
module_exit(process_info_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := process_info.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage

\subsection{任务4：使用 cgroup 实现限制 CPU 核数（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 使用cgroup实现限制CPU核数；
	\item 编写一个简单的c源程序，实现无线循环/死循环，使其占用某一进程（默认情况下会使得 cpu 资源消耗在 100）；
	\item 使用 cgexec与taskset 测试上述限制操作是否成功。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确、成功地限制CPU核数。
	\item 提交每一步操作以及结果显示的截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 挂载tmpfs格式的cgroup文件夹
	      \begin{lstlisting}[numbers=left]
# mkdir /cgroup
# mount -t tmpfs tmpfs /cgroup
# cd /cgroup
\end{lstlisting}
	\item 挂载cpuset管理子系统
	      \begin{lstlisting}
# mkdir cpuset
# mount -t cgroup -o cpuset cpuset /cgroup/cpuset    #挂载cpuset子系统
# cd cpuset
# mkdir mycpuset     #创建一个控制组，删除用 rmdir 命令
# cd mycpuset
\end{lstlisting}
	\item 设置cpu核数
	      \begin{lstlisting}
# cat cpuset.mems
# echo 0 > cpuset.mems
# cat cpuset.cpus
# echo 0-2 > cpuset.cpus
# cat cpuset.mems
# cat cpuset.cpus
# cd mycpuset
\end{lstlisting}
	\item 使用死循环C源文件\verb|while_long.c| 测试验证
\end{enumerate}

\newpage
\subsection{任务5：使用 cgroup 实现不允许访问U盘（15min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 使用cgroup实现不允许访问U盘。
	\item 使用 cgexec 与 dd 命令验证上述限制操作是否成功。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确、成功地限制U盘访问。
	\item 提交每一步操作以及结果显示的截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 将U盘插入树莓派，使用 fdisk -l 获取该U盘的盘符
	\item 调用shell命令 “ls -l”获取设备号
	\item 将U盘挂载到当前系统中
	      \begin{lstlisting}
# mkdir /usb
# mount /dev/sda4 /usb
\end{lstlisting}
	\item 挂载设备管理devices子系统
	      \begin{lstlisting}
# cd /cgroup/
# mkdir devices
# mount -t cgroup -o devices devices /cgroup/devices   #挂载devices子系统
# cd /cgroup/devices
# mkdir mydevices     # 创建mydevices控制组
# cd mydevices
\end{lstlisting}
	\item 设置拒绝U盘访问
	      \begin{lstlisting}
# echo 'a 8:4 rwm' > /cgroup/devices/mydevices/devices.deny
\end{lstlisting}
	\item 测试验证
\end{enumerate}

\newpage

\subsection{相关问题解决}

\begin{enumerate}

	\item 平均负载是指什么？\\
	      系统平均负载被定义为在特定时间间隔内运行队列中的平均进程数。
	\item 通过screen组件创建新终端
	      \begin{itemize}
		      \item 创建一个名字为XX的终端:\verb|screen -S XX|
		      \item 退出:按Ctrl+a，然后再按d
		      \item 查看所有的终端：\verb|screen -ls|
		      \item 进入终端界面:\verb|screen -r name-or-id|
		      \item 删除:\verb|screen -S name-or-id -X quit|
	      \end{itemize}
	\item 如果插入U盘后\verb|fdisk -l|命令找不到设备
	      \begin{itemize}
		      \item 检查U盘是否出现问题
		      \item 检查树莓派是否出现问题
		      \item 检查操作系统是否出现问题\\
		            操作系统问题可参考Issue: \url{https://gitee.com/openeuler/raspberrypi/issues/I45FML}
		            可能是内核版本问题造成的，尝试使用新内核
	      \end{itemize}
\end{enumerate}
\newpage


\section{中断和异常管理}
\subsection{任务1：使用tasklet实现打印helloworld（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块，使用tasklet实现打印helloworld。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑\verb|tasklet_interrupt.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/interrupt.h>

MODULE_LICENSE("GPL");

static struct tasklet_struct my_tasklet;

static void tasklet_handler(unsigned long data)//处理函数
{
	printk("Hello World! tasklet is working...\n");
}

static int __init mytasklet_init(void)
{
	printk("Start tasklet module...\n");
	tasklet_init(&my_tasklet, tasklet_handler, 0);//创建tasklet
	tasklet_schedule(&my_tasklet);//执行中断
	return 0;
}

static void __exit mytasklet_exit(void)
{
	tasklet_kill(&my_tasklet);//移除tasklet
	printk("Exit tasklet module...\n");
}

module_init(mytasklet_init);
module_exit(mytasklet_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := tasklet_interrupt.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage
\subsection{任务2：用工作队列实现周期打印helloworld（25min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写一个内核模块程序，用工作队列实现周期打印helloworld。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑\verb|workqueue_test.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/workqueue.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
static struct workqueue_struct *queue = NULL;
static struct delayed_work mywork;
static int i = 0;

// work handle
void work_handle(struct work_struct *work)
{
	printk(KERN_ALERT "Hello World! From 09021230 Yablin SUN\n");
}

static int __init timewq_init(void)
{
	printk(KERN_ALERT "Start workqueue_test module.");
	queue = create_singlethread_workqueue("workqueue_test");
	if (queue == NULL)
	{
		printk(KERN_ALERT "Failed to create workqueue_test!\n");
		return -1;
	}
	INIT_DELAYED_WORK(&mywork, work_handle);
	for (; i <= 3; i++)
	{
		queue_delayed_work(queue, &mywork, 1 * HZ);
		ssleep(2);
	}
	return 0;
}

static void __exit timewq_exit(void)
{
	flush_workqueue(queue);
	destroy_workqueue(queue);
	printk(KERN_ALERT "Exit workqueue_test module.");
}

module_init(timewq_init);
module_exit(timewq_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := workqueue_test.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko
\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage
\subsection{任务3：编写一个信号捕获程序，捕获终端按键信号（25min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 在用户态编写一个信号捕获程序，捕获终端按键信号。
	\item 编译上述程序后运行，在终端输入按键信号，查看输出信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\newpage
\begin{enumerate}
	\item 编辑\verb|catch_signal.c|
	      \begin{lstlisting}[numbers=left]
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void signal_handler(int sig)
{
	switch(sig){
		case SIGINT:
			printf("\nGet a signal:SIGINT. You pressed ctrl+c.\n");
			break;
		case SIGQUIT:
			printf("\nGet a signal:SIGQUIT. You pressed ctrl+\\.\n");
			break;
		case SIGTSTP:
			printf("\nGet a signal:SIGHUP. You pressed ctrl+z.\n");
			break;
	}
	exit(0);
}

int main()
{
	printf("Current process ID is %d\n", getpid());
	signal(SIGINT, signal_handler);
	signal(SIGQUIT, signal_handler);
	signal(SIGTSTP, signal_handler);
	for(;;);
}

\end{lstlisting}
	\item gcc编译源码
	\item 捕获信号
\end{enumerate}

\newpage


\section{内核时间管理}
\subsection{任务1：调用内核时钟接口打印当前时间（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块，调用内核时钟接口，打印出系统当前时间。格式示例：2020-03-09 11:54:31；
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑\verb|current_time.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/time.h>
#include <linux/rtc.h>

MODULE_LICENSE("GPL");

ktime_t k_time;
struct rtc_time tm;

static int __init currenttime_init(void)
{
	int year, mon, day, hour, min, sec;
	printk("Start current_time module...\n");
	k_time = ktime_get_real();
	tm = rtc_ktime_to_tm(k_time); 
	year = tm.tm_year + 1900;
	mon = tm.tm_mon + 1;
	day = tm.tm_mday;
	hour = tm.tm_hour + 8;
	min = tm.tm_min;
	sec = tm.tm_sec;
	printk("Current time is: %d-%02d-%02d %02d:%02d:%02d \t printed from SYL\n", year, mon, day, hour, min, sec);
	return 0;
}

static void __exit currenttime_exit(void)
{
	printk("Exit current_time module...\n");
}

module_init(currenttime_init);
module_exit(currenttime_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := current_time.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage


\subsection{任务2：编写timer，在特定时刻打印 hello,world（25min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块程序，实现一个timer，该定时器延时10秒后打印“hello,world”。
	\item 加载、卸载模块并查看模块打印信息。验证超时时间并截图。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|timer_example.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/timer.h>

MODULE_LICENSE("GPL");

struct timer_list timer;

void print(struct timer_list *timer)
{
	printk("hello,world!\t printed from SYL\n");
}

static int __init timer_init(void)
{
	printk("Start timer_example module...\n");
	timer.expires = jiffies + 10 * HZ;
	timer.function = print;
	add_timer(&timer);
	return 0;
}

static void __exit timer_exit(void)
{
	printk("Exit timer_example module...\n");
}

module_init(timer_init);
module_exit(timer_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := timer_example.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage




\subsection{任务3：调用内核时钟接口，监控累加计算代码的运行时间（40min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 调用内核时钟接口，编写内核模块，监控实现累加计算sum=1+2+3+...+100000 所花时间。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|sum_time.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/time.h>

MODULE_LICENSE("GPL");

#define NUM 100000

static long sum(int num)
{
	int i;
	long total = 0;
	for (i = 1; i <= NUM; i++)
		total = total + i;	
	return total;
}

static int __init sum_init(void)
{
	ktime_t startTime = 0;
    ktime_t endTime = 0;
    
	long time_cost;
	long s;

	printk("Start sum_time module...\n");
    
	startTime = ktime_get_real(); 
    s = sum(NUM);
    endTime = ktime_get_real(); 

	printk("The start time is: %lld ns \n", startTime);
    printk("The sum of 1 to %d is: %ld\n", NUM, s);
	printk("The end time is: %lld ns \n", endTime);
	
	printk("The cost time of sum from 1 to %d is: %lld ns \n", NUM, endTime - startTime);
	return 0;
}

static void __exit sum_exit(void)
{
	printk("Exit sum_time module...\n");
}

module_init(sum_init);
module_exit(sum_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := sum_time.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\subsection{相关问题解决}
\begin{enumerate}
	\item 编译报错\verb|error: implicit declaration of function 'do_gettimeofday'|
	      \begin{itemize}
		      \item \verb|do_gettimeofday()|函数在 linux kernel 5.x之后淘汰
		      \item 修改以下注释部分代码
		            \begin{lstlisting}[numbers=left]
//struct timeval tv;
//struct rtc_time tm;
ktime_t k_time;
struct rtc_time tm;

//do_gettimeofday(&tv);
//rtc_time_to_tm(tv.tv_sec, &tm);
k_time = ktime_get_real();
tm = rtc_ktime_to_tm(k_time); 
\end{lstlisting}
		      \item 操作系统的时间可能因为没有校准而显示与当前时间不同。\\
		            可以通过`date`命令查看Linux系统时间，并对比是否一致。
	      \end{itemize}
\end{enumerate}
\newpage
\section{设备管理}
\subsection{任务1：编写USB设备驱动程序（40min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 参考内核源码中的drivers/usb/usb-skeleton.c文件，编写一个USB探测驱动程序
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|usb_detect.c|注意修改设备号
	      \begin{lstlisting}[numbers=left]
/*
 * USB Detect driver
 * Written by 09021230 SYL
 * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c
 */

#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/kref.h>
#include <linux/uaccess.h>
#include <linux/usb.h>
#include <linux/mutex.h>


/* Define these values to match your devices */
#define USB_DETECT_VENDOR_ID	0x0781
#define USB_DETECT_PRODUCT_ID	0x5591

/* table of devices that work with this driver */
static const struct usb_device_id usbdetect_table[] = {
	{ USB_DEVICE(USB_DETECT_VENDOR_ID, USB_DETECT_PRODUCT_ID) },
	{ }					/* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, usbdetect_table);


/* Get a minor range for your devices from the usb maintainer */
#define USB_DETECT_MINOR_BASE	192

#define WRITES_IN_FLIGHT	8
/* arbitrarily chosen */

/* Structure to hold all of our device specific stuff */
struct usb_detect {
	struct usb_device	*udev;			/* the usb device for this device */
	struct usb_interface	*interface;		/* the interface for this device */
	struct semaphore	limit_sem;		/* limiting the number of writes in progress */
	struct usb_anchor	submitted;		/* in case we need to retract our submissions */
	struct urb		*bulk_in_urb;		/* the urb to read data with */
	unsigned char           *bulk_in_buffer;	/* the buffer to receive data */
	size_t			bulk_in_size;		/* the size of the receive buffer */
	size_t			bulk_in_filled;		/* number of bytes in the buffer */
	size_t			bulk_in_copied;		/* already copied to user space */
	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
	int			errors;			/* the last request tanked */
	bool			ongoing_read;		/* a read is going on */
	spinlock_t		err_lock;		/* lock for errors */
	struct kref		kref;
	struct mutex		io_mutex;		/* synchronize I/O with disconnect */
	unsigned long		disconnected:1;
	wait_queue_head_t	bulk_in_wait;		/* to wait for an ongoing read */
};
#define to_detect_dev(d) container_of(d, struct usb_detect, kref)

static struct usb_driver usbdetect_driver;

//USB 拔出中断
static void usbdetect_delete(struct kref *kref){
	struct usb_detect *dev = to_detect_dev(kref);

	usb_free_urb(dev->bulk_in_urb);
	usb_put_intf(dev->interface);
	usb_put_dev(dev->udev);
	kfree(dev->bulk_in_buffer);
	kfree(dev);
}

static const struct file_operations usbdetect_fops = {};

/*
 * usb class driver info in order to get a minor number from the usb core,
 * and to have the device registered with the driver core
 */
static struct usb_class_driver usbdetect_class = {
	.name =		">>> TEST <<<%d",
	.fops =		&usbdetect_fops,
	.minor_base =	USB_DETECT_MINOR_BASE,
};

//探测函数
static int usbdetect_probe(struct usb_interface *interface, const struct usb_device_id *id){
	struct usb_detect *dev;
	struct usb_endpoint_descriptor *bulk_in, *bulk_out;
	int retval;

	/* allocate memory for our device state and initialize it */
	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (!dev)
		return -ENOMEM;

	kref_init(&dev->kref);
	sema_init(&dev->limit_sem, WRITES_IN_FLIGHT);
	mutex_init(&dev->io_mutex);
	spin_lock_init(&dev->err_lock);
	init_usb_anchor(&dev->submitted);
	init_waitqueue_head(&dev->bulk_in_wait);

	dev->udev = usb_get_dev(interface_to_usbdev(interface));
	dev->interface = usb_get_intf(interface);

	/* set up the endpoint information */
	/* use only the first bulk-in and bulk-out endpoints */
	retval = usb_find_common_endpoints(interface->cur_altsetting,
			&bulk_in, &bulk_out, NULL, NULL);
	if (retval) {
		dev_err(&interface->dev,
			"Could not find both bulk-in and bulk-out endpoints\n");
		goto error;
	}

	dev->bulk_in_size = usb_endpoint_maxp(bulk_in);
	dev->bulk_in_endpointAddr = bulk_in->bEndpointAddress;
	dev->bulk_in_buffer = kmalloc(dev->bulk_in_size, GFP_KERNEL);
	if (!dev->bulk_in_buffer) {
		retval = -ENOMEM;
		goto error;
	}
	dev->bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->bulk_in_urb) {
		retval = -ENOMEM;
		goto error;
	}

	dev->bulk_out_endpointAddr = bulk_out->bEndpointAddress;

	/* save our data pointer in this interface device */
	usb_set_intfdata(interface, dev);

	/* we can register the device now, as it is ready */
	retval = usb_register_dev(interface, &usbdetect_class);
	if (retval) {
		/* something prevented us from registering this driver */
		dev_err(&interface->dev,
			"Not able to get a minor for this device.\n");
		usb_set_intfdata(interface, NULL);
		goto error;
	}

	/* let the user know what node this device is now attached to */
	dev_info(&interface->dev,
		 "USB detect device now attached to USBdetect-%d",
		 interface->minor);
	return 0;

error:
	/* this frees allocated memory */
	kref_put(&dev->kref, usbdetect_delete);

	return retval;
}

//拔出函数
static void usbdetect_disconnect(struct usb_interface *interface){
	struct usb_detect *dev;
	int minor = interface->minor;

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &usbdetect_class);

	/* prevent more I/O from starting */
	mutex_lock(&dev->io_mutex);
	dev->disconnected = 1;
	mutex_unlock(&dev->io_mutex);

	usb_kill_anchored_urbs(&dev->submitted);

	/* decrement our usage count */
	kref_put(&dev->kref, usbdetect_delete);

	dev_info(&interface->dev, "USB detect #%d now disconnected", minor);
}

static struct usb_driver usbdetect_driver = {
	.name =		">>> TEST <<<",
	.probe =	usbdetect_probe,
	.disconnect =	usbdetect_disconnect,
	.id_table =	usbdetect_table,
	.supports_autosuspend = 1,
};

//模块信息

MODULE_LICENSE("GPL v2");

static int __init usb_detect_init(void){
	int result;
	printk("Start usb_detect module...");
	/* register this driver with the USB subsystem */
	result = usb_register(&usbdetect_driver);
	if (result < 0) {
		printk("usb_register failed.""Error number %d", result);
		return -1;
	}
	return 0;
}

static void __exit usb_detect_exit(void)
{
	printk("Exit usb_detect module...");
	/* deregister this driver with the USB subsystem */
	usb_deregister(&usbdetect_driver);
}

module_init(usb_detect_init);
module_exit(usb_detect_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := usb_detect.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage

\subsection{任务2：编写内核模块测试硬盘的读写速率，并与 iozone工具的测试结果比较（45min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写内核模块测试硬盘的读写速率，加载、卸载模块并查看模块打印信息。
	\item 使用用户态下 iozone 工具测试硬盘的读写速率，注意：测试范围需包含与内核模块读写相同的文件大小和块大小。
	\item 对比用户态和内核态下测试的读写速率，并作分析。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 正确安装使用iozone工具测试硬盘读写速率。（可能会比较耗时）
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|write_to_disk.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/kernel.h> 
#include <linux/fs.h>
#include <linux/rtc.h>

#define buf_size 1024
#define write_times 524288

MODULE_LICENSE("GPL");

ktime_t startTime = 0;
ktime_t endTime = 0;

static int __init write_disk_init(void)
{
	struct file *fp_write;
	char buf[buf_size];
	int i;
	int write_time;
	loff_t pos;
	printk("Start write_to_disk module...\n");
	for(i = 0; i < buf_size; i++)
	{
		buf[i] = i + '0';
	}
	fp_write = filp_open("/home/tmp_file", O_RDWR | O_CREAT,0644);
	if (IS_ERR(fp_write)) {
		printk("Failed to open file...\n");
		return -1;
	}
	pos = 0;
    startTime = ktime_get_real();

	for(i = 0; i < write_times; i++) {
		kernel_write(fp_write, buf, buf_size, &pos);
	}
	endTime = ktime_get_real();
	filp_close(fp_write, NULL);
	write_time = (endTime - startTime) / 1000;
	printk(KERN_ALERT "Writing to file costs %d us\n", write_time);	
	printk("Writing speed is %d M/s\n", buf_size * write_times / write_time);
	return 0;
}

static void __exit write_disk_exit(void)
{
	printk("Exit write_to_disk module...\n");
}

module_init(write_disk_init);
module_exit(write_disk_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := write_to_disk.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
	\item 编辑\verb|write_to_disk.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/rtc.h>

#define buf_size 1024
#define read_times 524288

MODULE_LICENSE("GPL");

static int __init read_disk_init(void)
{
	struct file *fp_read;
	char buf[buf_size];
	int i;
	ktime_t startTime = 0;
	ktime_t endTime = 0;
	int read_time;
	loff_t pos;
	printk("Start read_from_disk module...\n");
	fp_read = filp_open("/home/tmp_file", O_RDONLY, 0);
	if (IS_ERR(fp_read)) {
		printk("Failed to open file...\n");
		return -1;
	}

    startTime = ktime_get_real();
	pos = 0;
	for(i = 0; i < read_times; i++)	{
		kernel_read(fp_read, buf, buf_size, &pos);
	}
	endTime = ktime_get_real();
	filp_close(fp_read, NULL);
	read_time = (endTime - startTime) / 1000;
	printk(KERN_ALERT "Read file costs %d us\n", read_time);	
	printk("Reading speed is %d M/s\n", buf_size * read_times / read_time);
	return 0;
}

static void __exit read_disk_exit(void)
{
	printk("Exit read_from_disk module...\n");
}

module_init(read_disk_init);
module_exit(read_disk_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := read_from_disk.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\subsection{相关问题解决}
编译报错\verb|error: implicit declaration of function 'do_gettimeofday'|
\begin{itemize}
	\item \verb|do_gettimeofday()|函数在 linux kernel 5.x之后淘汰
	\item 使用\verb|ktime_t|直接运算纳秒，除1000后即可得到原结果
\end{itemize}
\newpage
\section{文件管理}

\subsection{任务1：为 Ext4 文件系统添加扩展属性（25min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 熟悉文件系统扩展属性EA，查看树莓派文件系统是否支持EA。
	\item 使用setfattr设置文件系统的用户扩展属性，并设置文本、八进制数、十六进制数与base64编码这四种属性值。
	\item 使用getfattr获取文件系统的用户扩展属性，并在获取属性之后进行text、hex和base64这三种编码设置。
	\item 分析总结上述实验过程。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确使用setfattr设置EA，正确使用getfattr获取EA。
	\item 提交命令行的操作过程截图，以及实验分析总结。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 安装libattr
	      \begin{lstlisting}
# dnf install -y libattr
\end{lstlisting}

	\item 查看文件系统信息
	      \begin{lstlisting}
# df -Th
# fdisk -l
# tune2fs -l /dev/mmcblklp1 #分别查看上一命令打印的路径
# tune2fs -l /dev/mmcblklp2 #分别查看上一命令打印的路径
\end{lstlisting}
	\item 修改文件属性
	      \begin{itemize}
		      \item 纯文本属性
		            \begin{lstlisting}
# cd到目标文件夹
# vi file.txt #创建目标文件
# touch file.txt
# setfattr -n user.name -v SYL file.txt
# setfattr -n user.city -v "NanJing SEU" file.txt
# getfattr -d -m file.txt    #查看属性
\end{lstlisting}
		      \item 带有转义字符的属性
		            \begin{lstlisting}
# setfattr -n user.age -v \012 file.txt
# getfattr -d -m file.txt    #查看属性
\end{lstlisting}
		      \item 十六进制属性
		            \begin{lstlisting}
# setfattr -n user.hex -v 0x123 file.txt
# 报错，因为0x123为错误十六进制输入
# setfattr -n user.hex -v 0x1234 file.txt
# getfattr -d -m.file.txt    #查看属性
\end{lstlisting}
		      \item Base64属性
		            \begin{lstlisting}
# setfattr -n user.base64 -v 0s0123abcd== file.txt
# 报错，因为0s0123abcd==为错误Base64输入
# setfattr -n user.base64 -v 正确的Base64输入 file.txt
# getfattr -d -m.file.txt    #查看属性
\end{lstlisting}
		      \item 属性类型转换为txt格式
		            \begin{lstlisting}
# getfattr -d -e text file.txt
\end{lstlisting}
		      \item 属性类型转换为十六进制格式
		            \begin{lstlisting}
# getfattr -d -e hex file.txt
\end{lstlisting}
		      \item 属性类型转换为Base64格式
		            \begin{lstlisting}
# getfattr -d -e base64 file.txt
\end{lstlisting}
	      \end{itemize}
\end{enumerate}
\newpage
\subsection{任务2：注册一个自定义的文件系统类型（15min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 使用文件系统注册/注销函数，注册一个自定义文件系统类型；
	\item 加载模块后，查看系统中是否存在注册的文件系统类型。
	\item 加载、卸载模块并查看模块打印信息。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 查看系统中已经注册的文件系统类型
	      \begin{lstlisting}
# cat /proc/filesystems
\end{lstlisting}
	\item 编辑\verb|register_newfs.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/fs.h>

MODULE_LICENSE("GPL");

static struct file_system_type myfs_type = {
	.name	= ">> NewFS <<",
	.owner	= THIS_MODULE,
};
MODULE_ALIAS_FS(">> NewFS <<");

static int __init register_newfs_init(void)
{
	printk("Start register_newfs module...");
	return register_filesystem(&myfs_type);
}

static void __exit register_newfs_exit(void)
{
	printk("Exit register_newfs module...");
	unregister_filesystem(&myfs_type);
}

module_init(register_newfs_init);
module_exit(register_newfs_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := register_newfs.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
	      \begin{lstlisting}
# cat /proc/filesystems
\end{lstlisting}
\end{enumerate}

\newpage
\subsection{任务3：在/proc下创建目录（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写一个模块，在加载模块时，在/proc目录下创建一个名称为myproc的目录；
	\item 加载模块后，查看系统中是否在/proc目录下成功创建myproc目录。
	\item 加载、卸载模块并查看模块打印信息。

\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}
	\item 编辑\verb|proc_mkdir.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/module.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");

static struct proc_dir_entry *myproc_dir; 

static int __init myproc_init(void)
{
	int ret = 0;
	printk("Start proc_mkdir module...");
	myproc_dir = proc_mkdir("myproc",NULL);
	if(myproc_dir == NULL)
		return -ENOMEM;
	return ret;
}

static void __exit myproc_exit(void)
{
	printk("Exit proc_mkdir module...");
	proc_remove(myproc_dir);
}

module_init(myproc_init); 
module_exit(myproc_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := proc_mkdir.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage
\subsection{任务4：使用sysfs文件系统传递内核模块参数（20min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写一个模块，该模块有三个参数：一个为字符串型，两个为整型。
	      两个整型中，一个在/sys下不可见。
	\item 加载模块后，使用echo向模块传递参数值来改变指定参数的值。
	\item 加载、卸载模块并查看模块打印信息。

\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 正常加载、卸载内核模块；且内核模块功能满足任务所述。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑\verb|sysfs_exam.c|
	      \begin{lstlisting}[numbers=left]
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/stat.h>
 
MODULE_LICENSE("GPL");

static int a = 0;
static int b = 0;
static char * c = "Hello, World";
 
module_param(a, int, 0);
MODULE_PARM_DESC(a, "An invisible int under sysfs");
module_param(b, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
MODULE_PARM_DESC(b, "An visible int under sysfs");
module_param(c, charp, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
MODULE_PARM_DESC(c, "An visible string under sysfs");
 
static int __init sysfs_exam_init(void)
{
	printk("Start sysfs_exam module...");
	printk("a = %d\n", a);
	printk("b = %d\n", b);
	printk("c = '%s'\n", c);
	return 0; 
}

static void __exit sysfs_exam_exit(void) 
{
	printk("Exit sysfs_exam module...");
	printk("a = %d\n", a);
	printk("b = %d\n", b);
	printk("c = '%s'\n", c); 
}
 
module_init(sysfs_exam_init);
module_exit(sysfs_exam_exit);

\end{lstlisting}
	\item 编辑Makefile
	      \begin{lstlisting}[numbers=left]
ifneq ($(KERNELRELEASE),)
	obj-m := sysfs_exam.o
else
	KERNELDIR ?= /root/raspberrypi-kernel
	PWD := $(shell pwd)
default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
endif
.PHONY:clean
clean:
	-rm *.mod.c *.o *.order *.symvers *.ko

\end{lstlisting}
	\item 执行make编译源码
	\item 进行模块加载、查看、卸载
\end{enumerate}

\newpage


\section{网络管理}
\subsection{任务1：编写基于socket的udp发送接收程序（45min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 编写C源码，基于socket的udp发送接收程序，实现客户端与服务端的简单通信。
	\item 客户端从命令行输入中读取要发送的内容，服务端接收后实时显示。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑client.c
	      \begin{lstlisting}[numbers=left]
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT		40000
#define BUF_SIZE        1024

int main(void)
{
	int sock_fd;
	char buffer[BUF_SIZE];
	int size;
	int len;
	int ret;
	struct sockaddr_in server_addr;
	if(-1 == (sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)) ){
		printf("Failed to create a socket!\n");
		return 0;
	}

	//server infomation
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(PORT);
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	bzero(buffer, BUF_SIZE);
	len = sizeof(server_addr);

	//read from stdin and send to server
	while(1){
		printf("Please enter the content to be sent:\n");
		size = read(0, buffer, BUF_SIZE);
		if(size){
			sendto(sock_fd, buffer, size, 0, (struct sockaddr*)&server_addr, len);
			bzero(buffer, BUF_SIZE);
		}
	}
	close(sock_fd);
	return 0;
}

\end{lstlisting}
	\item 编辑server.c
	      \begin{lstlisting}[numbers=left]
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define	PORT		40000
#define	BUF_SIZE	1024

int main(void)
{
	int sock_fd;
	int len;
	char buffer[BUF_SIZE];
	struct sockaddr_in server_addr, client_addr;
	if(-1 == (sock_fd = socket(AF_INET, SOCK_DGRAM, 0)) )
	{
		printf("Failed to create a socket!\n");
		return 0;
	}
	//server information
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(PORT);
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	if(-1 == bind(sock_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)))
	{
		printf("Failed to bind the socket!\n");
		return 0;
	}
	len = sizeof(client_addr);
	
	//rec and print
	while(1)
	{
		bzero(buffer, BUF_SIZE);
		if(-1 != (recvfrom(sock_fd, buffer, BUF_SIZE, 0, (struct sockaddr*)&client_addr, &len)) )
		{
			printf("The message received is: %s", buffer);
		}
	}
	return 0;
}

\end{lstlisting}
	\item 在同一树莓派中，开启两个终端，一个运行客户端，一个运行服务端；
	\item client中输入发送的消息 回车后，server端即能收到。
\end{enumerate}

\newpage
\subsection{任务2：使用 tshark 抓包（10min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 基于任务1的服务端与客户端程序运行时，使用tshark抓取该通信数据包
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 安装wireshark(可能出现安装失败的情况，尝试安装正确的操作系统版本)
	      \begin{lstlisting}
# dnf install -y wireshark
\end{lstlisting}
	\item 抓包方法：\verb|tshark [options]| 可通过\verb|tshark -h| 查看具体选项参数
	\item 查看网卡信息
	      \begin{lstlisting}
# ifconfig
\end{lstlisting}
	\item 找到回环地址\verb|lo|
	\item 抓包
	      \begin{lstlisting}
# tshark -i lo -n -f 'udp port 40000' #直接把抓包结果输出到命令行
# tshark -i lo -n -f 'udp port 40000' -T pdml > /root/task2.xml  #把抓包结果以指定格式输出到指定文件中

\end{lstlisting}
	\item 按照实验一进行通信
	\item 查看抓包结果
\end{enumerate}

\newpage
\subsection{任务3：使用 setsockopt 发送记录路由选项（25min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 基于任务1的客户端与服务端，使用setsockopt发送一个带IP记录路由选项的数据包；
	\item 使用tshark查看发送的数据包中是否包含了记录路由选项。

\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确编写满足功能的源文件，正确编译。
	\item 提交相关源码与运行截图。
\end{enumerate}

\subsubsection{操作指南}
\begin{enumerate}

	\item 编辑client.c
	      \begin{lstlisting}[numbers=left]
# #include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT		40000
#define BUF_SIZE        1024

int main(void)
{
	int sock_fd;
	char buffer[BUF_SIZE];
	char rrbuf[28];
	int size;
	int len;
	int ret;

	struct sockaddr_in server_addr;

	if(-1 == (sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)) ){
		printf("Failed to create a socket!\n");
		return 0;
	}

	//server infomation
	memset(&server_addr, 0, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(PORT);
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	bzero(buffer, BUF_SIZE);
	len = sizeof(server_addr);

	//read from stdin and send to server
	while(1){
		printf("Please enter the content to be sent:\n");
		size = read(0, buffer, BUF_SIZE);
		if(size){
			bzero(rrbuf,sizeof(rrbuf));
			rrbuf[0] = 0x07;
			rrbuf[1] = sizeof(rrbuf) - 1;
			rrbuf[2] = 4;
			rrbuf[sizeof(rrbuf) - 1] = 0;
			
			ret = setsockopt(sock_fd,IPPROTO_IP,IP_OPTIONS,(void*)rrbuf,sizeof(rrbuf));
			if(-1 == ret){
				printf("setsockopt error!\n");
				return 0;
			}

			sendto(sock_fd, buffer, size, 0, (struct sockaddr*)&server_addr, len);
			bzero(buffer, BUF_SIZE);
		}
	}
	close(sock_fd);
	return 0;
}

\end{lstlisting}
	\item 使用实验一的server.c
	\item 编译并执行代码
	      \begin{lstlisting}
        # ./client
        # ./server
        # tshark -i lo -n -f 'udp port 40000'-T pdml >./setsockopt.xml
    \end{lstlisting}
	\item 查看\verb|setsockopt.xml|内容
\end{enumerate}

\newpage

\section{内核虚拟化}
\textbf{因华为官方对系统版本维护原因，该实验目前暂时无法完成}

\subsection{任务1：树莓派4B中搭建openEule系统的qemu虚拟机（50min）}
\subsubsection{任务描述}
\begin{enumerate}
	\item 在树莓派4B中，使用libvirt+xml配置文件的方法，搭建openEuler-20.03-aarch64系统的qemu虚拟机运行环境。
	\item 在windows主机和树莓派中安装VNC工具，完成虚拟机的安装与使用。
\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 在树莓派4B中正确安装使用aarch64架构的openEuler虚拟机qemu运行环境。
	\item 提交关键过程的截图。
\end{enumerate}
\subsection{任务2：在树莓派中搭建和使用docker（30min）}

\subsubsection{任务描述}
\begin{enumerate}
	\item 在树莓派的openEuler运行环境中，安装使用docker；完成docker容器的新建、启动、守护态运行、终止与删除等操作。
	\item 编写 Dockerfile 文件，创建基于ubuntu镜像，创建打印“Hello world”的docker镜像，并验证其可用性。

\end{enumerate}

\subsubsection{审核要求}
\begin{enumerate}
	\item 正确安装、配置与使用docker。
	\item 正确创建功能正常的自定义docker镜像。
	\item 提交关键流程与截图。
\end{enumerate}


\end{document}
